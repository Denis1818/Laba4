Введение
Данная лабораторная работа посвящена разработке класса QuadraticEquation, представляющего квадратное уравнение вида ax² + bx + c = 0. Работа разделена на два этапа: создание базового класса с основным функционалом и расширение его возможностей через перегрузку операторов в C++.

Задание 1: Базовый класс Quadratic1
Структура класса
Класс Quadratic1 инкапсулирует коэффициенты квадратного уравнения и предоставляет интерфейс для работы с ними.

Архитектура класса:


class Quadratic1 {
private:
    double a_;  // Коэффициент при x² (не должен быть равен 0)
    double b_;  // Коэффициент при x
    double c_;  // Свободный член
    // ... методы и операторы
};
Ключевые особенности реализации
Конструкторы
1.Конструктор по умолчанию: Создает уравнение x² = 0


Quadratic1::Quadratic1() : a_(1.0), b_(0.0), c_(0.0) {}
2.Конструктор с параметрами: Принимает конкретные значения коэффициентов


Quadratic1::Quadratic1(double a, double b, double c)
    : a_(a), b_(b), c_(c) {}
3.Конструктор копирования: Создает точную копию существующего объекта


Quadratic1::Quadratic1(const Quadratic1& other)
    : a_(other.a_), b_(other.b_), c_(other.c_) {}
Метод FindRoots()
Основной математический метод класса, реализующий алгоритм нахождения корней квадратного уравнения:


double* Quadratic1::FindRoots() const {
    double discriminant = b_ * b_ - 4 * a_ * c_;  // D = b² - 4ac
    static double roots[2];  // Статический массив для возврата результата
    
    if (discriminant > 0) {
        // Два различных действительных корня
        roots[0] = (-b_ + sqrt(discriminant)) / (2 * a_);
        roots[1] = (-b_ - sqrt(discriminant)) / (2 * a_);
    }
    else if (discriminant == 0) {
        // Один действительный корень (кратности 2)
        roots[0] = -b_ / (2 * a_);
        roots[1] = roots[0];
    }
    else {
        // Нет действительных корней
        roots[0] = roots[1] = 0.0;
    }
    
    return roots;  // Возвращаем указатель на массив
}
Важные аспекты:

Использование static массива предотвращает уничтожение данных после выхода из функции

Метод всегда возвращает массив из двух элементов для единообразия интерфейса

В случае отрицательного дискриминанта возвращаются нули как индикатор отсутствия действительных корней

Оператор вывода
Перегрузка оператора << обеспечивает форматированный вывод уравнения:


std::ostream& operator<<(std::ostream& os, const Quadratic1& eq) {
    os << eq.a_ << "x²";
    
    // Интеллектуальная обработка знаков коэффициентов
    if (eq.b_ >= 0) {
        os << " + " << eq.b_ << "x";
    } else {
        os << " - " << -eq.b_ << "x";
    }
    
    if (eq.c_ >= 0) {
        os << " + " << eq.c_;
    } else {
        os << " - " << -eq.c_;
    }
    
    os << " = 0";
    return os;
}
Примеры форматирования:

2x² - 5x + 3 = 0 (при a=2, b=-5, c=3)

1x² + 0x - 4 = 0 (при a=1, b=0, c=-4)

3x² + 2x + 1 = 0 (при a=3, b=2, c=1)

Механизм работы программы
Инициализация объектов: Программа создает три объекта разными способами

Ввод данных: Коэффициенты вводятся с клавиатуры с защитой от ошибок

Вычисление корней: Для каждого уравнения вызывается FindRoots()

Вывод результатов: Используется перегруженный operator<< для красивого отображения

Пример выполнения:


=== ЗАДАЧА 1: Quadratic1 (Базовый класс) ===

1. Тестирование конструктора по умолчанию:
Создано уравнение: 1x² + 0x + 0 = 0
Корни уравнения: 0, 0

2. Тестирование конструктора с параметрами:
Введите коэффициент a: 2
Введите коэффициент b: -5
Введите коэффициент c: 3
Создано уравнение: 2x² - 5x + 3 = 0
Корни уравнения: 1.5, 1
Задание 2: Класс Quadratic2 с перегруженными операторами
Расширение функционала
Класс Quadratic2 наследует базовый функционал и добавляет поддержку операторов, что позволяет работать с объектами более естественным образом.

Унарные операторы инкремента и декремента
Операторы ++ и -- изменяют все коэффициенты уравнения на 1.

Префиксный инкремент:


Quadratic2& Quadratic2::operator++() {
    ++a_;  // Увеличиваем коэффициент a
    ++b_;  // Увеличиваем коэффициент b  
    ++c_;  // Увеличиваем коэффициент c
    return *this;  // Возвращаем ссылку на измененный объект
}
Использование: ++equation или Quadratic2 result = ++equation

Постфиксный инкремент:


Quadratic2 Quadratic2::operator++(int) {
    Quadratic2 temp(*this);  // Сохраняем текущее состояние
    ++(*this);              // Увеличиваем коэффициенты
    return temp;            // Возвращаем старое состояние
}
Использование: equation++ или Quadratic2 result = equation++

Фиктивный параметр int отличает постфиксную форму от префиксной - это стандартное соглашение в C++.

Операторы приведения типа
Неявное приведение к double (дискриминант):


Quadratic2::operator double() const {
    return b_ * b_ - 4 * a_ * c_;
}
Использование: double d = equation; автоматически вычисляет дискриминант

Явное приведение к bool (проверка корней):


explicit operator bool() const {
    double discriminant = b_ * b_ - 4 * a_ * c_;
    return discriminant >= 0;  // true если есть действительные корни
}
Использование: bool hasRoots = static_cast<bool>(equation);

Ключевое слово explicit предотвращает неявные преобразования, требуя явного приведения типа.

Операторы сравнения
Оператор равенства:


bool Quadratic2::operator==(const Quadratic2& other) const {
    const double epsilon = 1e-9;  // Допустимая погрешность
    return (fabs(a_ - other.a_) < epsilon) &&
           (fabs(b_ - other.b_) < epsilon) &&
           (fabs(c_ - other.c_) < epsilon);
}
Использование: if (eq1 == eq2) { ... }

Оператор неравенства:


bool Quadratic2::operator!=(const Quadratic2& other) const {
    return !(*this == other);  // Используем уже реализованный ==
}
Важно: Для сравнения чисел с плавающей точкой используется эпсилон-окрестность, так как точное равенство маловероятно из-за ошибок округления.

Пример работы с перегруженными операторами

// Создание уравнений
Quadratic2 eq1(1, 2, 1);  // x² + 2x + 1 = 0
Quadratic2 eq2(2, 3, 4);  // 2x² + 3x + 4 = 0

// Унарные операции
Quadratic2 eq3 = ++eq1;   // eq1: 2x² + 3x + 2 = 0, eq3 содержит то же
Quadratic2 eq4 = eq2++;   // eq2: 3x² + 4x + 5 = 0, eq4 содержит старое значение

// Приведение типов
double discriminant = eq1;  // Неявное: дискриминант
bool hasRealRoots = static_cast<bool>(eq1);  // Явное: есть ли корни

// Сравнение
bool areEqual = (eq1 == eq2);  // Сравнение коэффициентов
bool areDifferent = (eq1 != eq2);
Демонстрация работы программы

=== ЗАДАЧА 2: Quadratic2 С ПЕРЕГРУЖЕННЫМИ ОПЕРАЦИЯМИ ===

1. Создание тестовых уравнений:
Введите коэффициент a для уравнения 1: 1
Введите коэффициент b для уравнения 1: 2
Введите коэффициент c для уравнения 1: 1
Создано уравнение 1: 1x² + 2x + 1 = 0

2. Тестирование унарных операций:
Префиксный ++eq1:
До: 1x² + 2x + 1 = 0
После: 2x² + 3x + 2 = 0
Результат: 2x² + 3x + 2 = 0

Постфиксный eq2++:
До: 1x² + 2x + 1 = 0  
После: 2x² + 3x + 2 = 0
Результат: 1x² + 2x + 1 = 0

3. Тестирование операций приведения типа:
Неявное приведение eq1 к double: -7 (дискриминант)
Явное приведение eq1 к bool: false (действительные корни не существуют)

4. Тестирование бинарных операций:
eq1 == eq2: false
eq1 != eq2: true
