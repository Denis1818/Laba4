Перегрузка операторов
Вариант 6

ЗАДАЧА 1
Название класса: QuadraticEquation (в коде Quadratic1)
Поля:

double a – коэффициент при x²

double b – коэффициент при x

double c – свободный член

Метод:
double* FindRoots() – вычисление корней квадратного уравнения. Результат – массив типа double (от 0 до 2 элементов в зависимости от количества корней).

Алгоритм (как работает код):

В main программа запускает меню, пользователь выбирает задачу 1.

Создаются три тестовых объекта разными конструкторами:

Конструктор по умолчанию (a=1, b=0, c=0)

Конструктор с параметрами (вводятся с клавиатуры)

Конструктор копирования

Для каждого уравнения вызывается FindRoots():

Вычисляется дискриминант: D = b² - 4ac

Если D > 0 – два корня: (-b ± √D) / (2a)

Если D = 0 – один корень (возвращается дважды)

Если D < 0 – возвращается {0, 0} (условное обозначение)

Выводится уравнение в формате ax² + bx + c = 0 через перегруженный operator<<.

Тестируются сеттеры и геттеры – изменяются коэффициенты и проверяется работа.

Пример (консоль):


=== ЗАДАЧА 1: Quadratic1 (Базовый класс) ===

1. Тестирование конструктора по умолчанию:
Создано уравнение: 1x² + 0x + 0 = 0
Корни уравнения: 0, 0

2. Тестирование конструктора с параметрами:
Введите коэффициент a: 2
Введите коэффициент b: -5
Введите коэффициент c: 3
Создано уравнение: 2x² - 5x + 3 = 0
Корни уравнения: 1.5, 1

3. Тестирование конструктора копирования:
Скопировано уравнение: 2x² - 5x + 3 = 0
Корни уравнения: 1.5, 1

ЗАДАЧА 1
Название класса: QuadraticEquation (в коде Quadratic1)
Поля:

double a – коэффициент при x²

double b – коэффициент при x

double c – свободный член

Метод:
double* FindRoots() – вычисление корней квадратного уравнения. Результат – массив типа double (от 0 до 2 элементов в зависимости от количества корней).

 Объяснение кода для Задачи 1
1. Заголовочный файл Zadan1.h

#ifndef ZADAN1_H
#define ZADAN1_H

#include <iostream>

class Quadratic1 {
private:
    double a_;  // Приватные поля с подчёркиванием (стиль)
    double b_;
    double c_;

public:
    // Конструкторы (три, как требуется)
    Quadratic1();                           // По умолчанию
    Quadratic1(double a, double b, double c); // С параметрами
    Quadratic1(const Quadratic1& other);    // Копирования

    // Геттеры (константные методы, не меняют объект)
    double GetA() const;  // Возвращает значение a_
    double GetB() const;  // Возвращает значение b_
    double GetC() const;  // Возвращает значение c_

    // Сеттеры (меняют поля объекта)
    void SetA(double a);  // Устанавливает новое значение для a_
    void SetB(double b);  // Устанавливает новое значение для b_
    void SetC(double c);  // Устанавливает новое значение для c_

    // Основной метод по варианту
    double* FindRoots() const;  // Вычисляет корни уравнения

    // Дружественная функция для вывода
    friend std::ostream& operator<<(std::ostream& os, const Quadratic1& eq);
};

#endif
Что здесь важно:

#ifndef/#define/#endif – защита от повторного включения файла

private: – поля скрыты от прямого доступа (инкапсуляция)

const после метода – метод не меняет состояние объекта

friend – функция operator<< получает доступ к приватным полям

2. Реализация Zadan1.cpp

#include "Zadan1.h"
#include <cmath>    // для sqrt()
#include <iostream>

// Конструктор по умолчанию
Quadratic1::Quadratic1() : a_(1.0), b_(0.0), c_(0.0) {}
// Используется список инициализации: a_(1.0), b_(0.0), c_(0.0)
// Уравнение: x² = 0

// Конструктор с параметрами
Quadratic1::Quadratic1(double a, double b, double c)
    : a_(a), b_(b), c_(c) {
    // Просто инициализирует поля значениями параметров
}

// Конструктор копирования
Quadratic1::Quadratic1(const Quadratic1& other)
    : a_(other.a_), b_(other.b_), c_(other.c_) {
    // Копирует значения из другого объекта
}
Геттеры и сеттеры:


double Quadratic1::GetA() const { return a_; }
double Quadratic1::GetB() const { return b_; }
double Quadratic1::GetC() const { return c_; }

void Quadratic1::SetA(double a) { a_ = a; }
void Quadratic1::SetB(double b) { b_ = b; }
void Quadratic1::SetC(double c) { c_ = c; }
// Просто возвращают/устанавливают значения
Метод FindRoots():


double* Quadratic1::FindRoots() const {
    double discriminant = b_ * b_ - 4 * a_ * c_;  // D = b² - 4ac
    static double roots[2];  // Статический массив (существует до конца программы)

    if (discriminant > 0) {
        // Два различных корня
        roots[0] = (-b_ + sqrt(discriminant)) / (2 * a_);
        roots[1] = (-b_ - sqrt(discriminant)) / (2 * a_);
    }
    else if (discriminant == 0) {
        // Один корень (два одинаковых)
        roots[0] = -b_ / (2 * a_);
        roots[1] = roots[0];  // Дублируем для массива из 2 элементов
    }
    else {
        // Комплексные корни (в задании не обрабатываются)
        roots[0] = roots[1] = 0.0;  // Возвращаем нули как индикатор
    }

    return roots;  // Возвращаем указатель на массив
}
Перегрузка оператора вывода:


std::ostream& operator<<(std::ostream& os, const Quadratic1& eq) {
    os << eq.a_ << "x²";  // Выводим первый коэффициент
    
    // Выводим второй коэффициент со знаком
    if (eq.b_ >= 0) {
        os << " + " << eq.b_ << "x";
    }
    else {
        os << " - " << -eq.b_ << "x";  // Минус уже в числе, выводим как "-"
    }
    
    // Выводим третий коэффициент со знаком
    if (eq.c_ >= 0) {
        os << " + " << eq.c_;
    }
    else {
        os << " - " << -eq.c_;
    }
    
    os << " = 0";  // Завершаем уравнение
    return os;  // Возвращаем поток для цепочки вызовов
}
Пример работы оператора <<:

Для a=2, b=-3, c=1 выведет: 2x² - 3x + 1 = 0

Для a=1, b=0, c=-4 выведет: 1x² + 0x - 4 = 0

3. Тестирование в main.cpp (часть Task1)

void Task1() {
    std::cout << "\n=== ЗАДАЧА 1: Quadratic1 (Базовый класс) ===" << std::endl;

    // Тест 1: Конструктор по умолчанию
    Quadratic1 eq1;  // Вызывается Quadratic1()
    std::cout << "Создано уравнение: " << eq1 << std::endl;
    // Вызывается operator<<(cout, eq1)
    
    double* roots1 = eq1.FindRoots();  // Получаем указатель на массив корней
    std::cout << "Корни уравнения: " << roots1[0] << ", " << roots1[1] << std::endl;
    // roots1[0] и roots1[1] - элементы массива

    // Тест 2: Конструктор с параметрами
    double a1 = InputDouble("Введите коэффициент a: ");
    // InputDouble() защищает от некорректного ввода
    Quadratic1 eq2(a1, b1, c1);  // Конструктор с параметрами
    // ... аналогичные тесты для других конструкторов и методов
}

Пример работы:


=== ЗАДАЧА 1: Quadratic1 (Базовый класс) ===

1. Тестирование конструктора по умолчанию:
Создано уравнение: 1x² + 0x + 0 = 0  ← Вызов operator<<
Корни уравнения: 0, 0                 ← Результат FindRoots()

2. Тестирование конструктора с параметрами:
Введите коэффициент a: 2
Введите коэффициент b: -5
Введите коэффициент c: 3
Создано уравнение: 2x² - 5x + 3 = 0
Корни уравнения: 1.5, 1               ← D=1, корни: (5±1)/4



ЗАДАЧА 2
Название класса: QuadraticEquation (в коде Quadratic2)
Добавленные перегруженные операции:

Унарные операции:

++ – увеличивает коэффициенты уравнения на 1

-- – уменьшает коэффициенты уравнения на 1
(реализованы в префиксной и постфиксной формах)

Операции приведения типа:

operator double() – неявное приведение к double (возвращает дискриминант)

explicit operator bool() – явное приведение к bool (true, если корни существуют)

Бинарные операции:

== – уравнения равны, если равны их коэффициенты

!= – уравнения не равны, если не равны их коэффициенты

Алгоритм (как работает код):

1.Пользователь выбирает задачу 2 в меню.

2.Создаются два уравнения с вводом коэффициентов с клавиатуры.

3.Тестируются унарные операции:

++eq (префиксный) – увеличивает все коэффициенты на 1, возвращает изменённый объект

eq++ (постфиксный) – возвращает копию, потом увеличивает

Аналогично для --

4.Тестируются операции приведения типа:

double d = eq; – неявное приведение к double (дискриминант)

bool b = static_cast<bool>(eq); – явное приведение к bool (есть ли корни)

5.Тестируются бинарные операции:

eq1 == eq2 – сравнивает коэффициенты a, b, c

eq1 != eq2 – обратное сравнение

6.Для финальных уравнений вычисляются и выводятся корни.

Пример (консоль):



=== ЗАДАЧА 2: Quadratic2 С ПЕРЕГРУЖЕННЫМИ ОПЕРАЦИЯМИ ===

1. Создание тестовых уравнений:
Введите коэффициент a для уравнения 1: 1
Введите коэффициент b для уравнения 1: 2
Введите коэффициент c для уравнения 1: 1
Создано уравнение 1: 1x² + 2x + 1 = 0

2. Тестирование ударных операций:
Префиксный ++eq1:
До: 1x² + 2x + 1 = 0
После: 2x² + 3x + 2 = 0
Результат: 2x² + 3x + 2 = 0

3. Тестирование операций приведения типа:
Неявное приведение eq1 к double: -7 (дискриминант)
Явное приведение eq1 к bool: false (действительные корни существуют)

4. Тестирование бинарных операций:
eq1 == eq2: false
eq1 != eq2: true

Особенности реализации
Корректный ввод: Функция InputDouble() защищает от некорректного ввода

Перегрузка operator<<: Уравнение выводится с правильными знаками (±)

Статический массив в FindRoots: Безопасное возвращение массива корней

Префиксные/постфиксные операторы: Реализованы обе формы для ++ и --

Явное/неявное приведение:

operator double() – неявное (можно использовать в выражениях)

explicit operator bool() – требует явного приведения


Объяснение кода для Задачи 2
1. Заголовочный файл Zadan2.h

#ifndef ZADAN2_H
#define ZADAN2_H

#include <iostream>

class Quadratic2 {
private:
    double a_, b_, c_;  // Те же поля

public:
    // Конструкторы (аналогично Quadratic1)
    Quadratic2();
    Quadratic2(double a, double b, double c);
    Quadratic2(const Quadratic2& other);

    // Геттеры и сеттеры
    double GetA() const; double GetB() const; double GetC() const;
    void SetA(double a); void SetB(double b); void SetC(double c);

    // Метод вычисления корней
    double* FindRoots() const;

    // УНАРНЫЕ ОПЕРАТОРЫ (префиксные и постфиксные)
    Quadratic2& operator++();     // ++obj (префиксный)
    Quadratic2 operator++(int);   // obj++ (постфиксный) - int фиктивный параметр
    Quadratic2& operator--();     // --obj
    Quadratic2 operator--(int);   // obj--

    // ОПЕРАТОРЫ ПРИВЕДЕНИЯ ТИПА
    operator double() const;      // Неявное: double d = obj;
    explicit operator bool() const; // Явное: bool b = static_cast<bool>(obj);

    // БИНАРНЫЕ ОПЕРАТОРЫ
    bool operator==(const Quadratic2& other) const;  // obj1 == obj2
    bool operator!=(const Quadratic2& other) const;  // obj1 != obj2

    // Дружественный оператор вывода
    friend std::ostream& operator<<(std::ostream& os, const Quadratic2& eq);
};

#endif
2. Реализация унарных операторов в Zadan2.cpp

// Префиксный ++ (++obj)
Quadratic2& Quadratic2::operator++() {
    ++a_;  // Увеличиваем a на 1
    ++b_;  // Увеличиваем b на 1
    ++c_;  // Увеличиваем c на 1
    return *this;  // Возвращаем ссылку на изменённый объект
}

// Постфиксный ++ (obj++)
Quadratic2 Quadratic2::operator++(int) {
    Quadratic2 temp(*this);  // Сохраняем текущее состояние
    ++(*this);               // Увеличиваем текущий объект (вызываем префиксный ++)
    return temp;             // Возвращаем старое состояние
}
Разница префиксного и постфиксного:

++obj → меняет объект, возвращает ссылку на него

obj++ → возвращает копию старого значения, потом меняет объект

int параметр в постфиксной версии – фиктивный, только для различия

3. Реализация операторов приведения типа

// Неявное приведение к double (возвращает дискриминант)
Quadratic2::operator double() const {
    return b_ * b_ - 4 * a_ * c_;  // Просто вычисляем и возвращаем double
}

// Явное приведение к bool (проверяет существование корней)
Quadratic2::operator bool() const {
    double discriminant = b_ * b_ - 4 * a_ * c_;
    return discriminant >= 0;  // true если корни есть (D ≥ 0)
}
Как используется:


Quadratic2 eq(1, 2, 1);
double d = eq;          // Неявное: d = 0.0 (дискриминант)
bool b = static_cast<bool>(eq);  // Явное: b = true (корни есть)

4. Реализация бинарных операторов

// Оператор == (сравнивает коэффициенты)
bool Quadratic2::operator==(const Quadratic2& other) const {
    // Сравниваем все три коэффициента с небольшой погрешностью
    const double epsilon = 1e-9;  // Для сравнения double
    return (fabs(a_ - other.a_) < epsilon) &&
           (fabs(b_ - other.b_) < epsilon) &&
           (fabs(c_ - other.c_) < epsilon);
}

// Оператор != (противоположность ==)
bool Quadratic2::operator!=(const Quadratic2& other) const {
    return !(*this == other);  // Используем уже реализованный ==
}
Важно: Для сравнения double используется fabs() и эпсилон, т.к. числа с плавающей точкой неточны.

5. Тестирование в main.cpp (часть Task2)

void Task2() {
    // ... создание уравнений eq1 и eq2
    
    // Тестирование унарных операций
    std::cout << "Префиксный ++eq1:" << std::endl;
    std::cout << "До: " << eq1 << std::endl;
    Quadratic2 eq1_prefix = ++eq1;  // 1. Увеличиваем eq1, 2. Присваиваем
    std::cout << "После: " << eq1 << std::endl;
    std::cout << "Результат: " << eq1_prefix << std::endl;
    
    // Тестирование приведения типов
    double discriminant = eq1;  // Неявное приведение: вызов operator double()
    std::cout << "Дискриминант: " << discriminant << std::endl;
    
    bool has_roots = static_cast<bool>(eq1);  // Явное приведение
    std::cout << "Есть корни: " << (has_roots ? "да" : "нет") << std::endl;
    
    // Тестирование бинарных операций
    bool are_equal = (eq1 == eq2);  // Вызов operator==
    std::cout << "eq1 == eq2: " << are_equal << std::endl;
}
 Детальное объяснение работы программы
Как работает FindRoots() с возвратом массива:

double* roots = eq.FindRoots();
// roots указывает на static массив внутри функции
// Можно безопасно использовать roots[0] и roots[1]
Почему static массив безопасен:

Обычный локальный массив уничтожился бы после выхода из функции

Static массив существует всё время работы программы

Можно вернуть указатель на него без риска

Как работает перегрузка operator<<:

std::cout << eq;  // Преобразуется в: operator<<(cout, eq)
Компилятор ищет функцию operator<< которая принимает ostream& и Quadratic2&.

Почему разные операторы приведения:

operator double() const;      // Неявное - может использоваться автоматически
explicit operator bool() const; // Явное - требует static_cast
double d = eq; – работает без явного приведения

bool b = eq; – НЕ сработает (явное приведение)

bool b = static_cast<bool>(eq); – требуется явное указание

Пример полного вычисления:

Quadratic2 eq(1, -3, 2);  // x² - 3x + 2 = 0

// Находим корни:
// D = (-3)² - 4*1*2 = 9 - 8 = 1
// x1 = (3 + 1) / 2 = 2
// x2 = (3 - 1) / 2 = 1

double d = eq;  // d = 1.0 (дискриминант)
bool b = static_cast<bool>(eq);  // b = true (D ≥ 0)
⚙️ Технические детали реализации
Защита от деления на ноль в FindRoots():
В текущей реализации нет проверки a == 0. Если a == 0, уравнение становится линейным, но метод всё равно будет работать (хотя математически некорректно).

Точность вычислений:
Используется sqrt() из <cmath> для вычисления квадратного корня.

Обработка отрицательного дискриминанта:
Возвращается {0, 0}. В реальном проекте лучше вернуть NaN или выбросить исключение.

Копирование объектов:
Конструктор копирования создаёт полную копию, что важно при работе с операторами.

Цепочка вызовов:


std::cout << "Уравнение: " << eq << " имеет корни: " << roots[0] << ", " << roots[1];
Каждый << возвращает ссылку на поток, что позволяет делать цепочки.
